## 컴포넌트의 구조 및 사용

### 컴포넌트란?

Angular의 애플리케이션은 컴포넌트(Component)를 중심으로 구성(CBM, Component Based Development)된다.  
컴포넌트의 역활은 애플리케이션의 화면을 구성하는 뷰(View)를 생성, 관리하는 것이며 Angular는 이러한 컴포넌트를 조립하여 하나의 완성된 애플리케이션을 작성한다.

### 코드 구조

[##_Image|kage@8qVRa/btqHhRgNEIQ/OZOsKIT4qRAx7HqUHMqMkk/img.png|alignCenter|width="100%"|_##]

**1\. 임포트 영역**  
컴포넌트에 필요한 의존 모듈을 임포트한다.  
Angular 라이브러리의 모듈은 ‘@’가 붙어있으며 npm을 사용하여 설치한 의존 모듈과 함께 경로를 표기하지 않는다. (그 이외의 경우는 상대 경로를 명시하여야 한다.)

**2\. @Component 데코레이터 영역**  
@Component 데코레이터의 인자는 메타데이터 객체를 전달한다.  
메타데이터 객체는 셀렉터, 템플릿, 스타일 정의 등의 컴포넌트 생성에 필요한 정보를 담고 있다.

**3\. 컴포넌트 클래스 영역**  
컴포넌트 뷰를 관리하기 위한 로직을 담은 클래스를 정의한다.  
컴포넌트의 내부 관심사인 뷰의 관리에 집중해야하며 애플리케이션 공통 괌심사는 서비스로 분리하여야 한다.

주의해야 할 것은 @Component 데코레이터는 자신의 바로 아래에 위치한 클래스를 컴포넌트로 인식하기 때문에 컴포넌트 클래스는 @Component 데코레이터의 바로 아래 위치시켜야 한다.  
(즉 @Component 데코레이터와 컴포넌트 클래스의 사이에 아무것도 존재해서는 안됨)

### 기본 동작 구조

html은 @Component 데코레이터의 templateUrl 프로퍼티에 설정된 템플릿으로 컴포넌트의 뷰는 HTML과 Angular 고유의 템플릿 문법으로 작성한다.  
{{ title }}은 템플릿 문법의 하나인 인터폴레이션으로 컴포넌트 클래스의 데이터를 템플릿에 바인딩하는 데 이러한 방식을 데이터 바인딩(Data Binding)이라고 한다.  
( ‘/src/app/app.component.ts’의 컴포넌트 클래스의 프로퍼티 title의 값이 {{ title }}에 바인딩 됨 )

컴포넌트는 데이터 바인딩에 의해 템플릿과 컴포넌트 클래스의 데이터를 유기적으로 연계하는 데 기본적인 동작구조는 아래 그림과 같다.

[##_Image|kage@btcDr7/btqG9S2mHDd/TJ9zgqaJmZegXu5q6qU00K/img.png|alignCenter|data-origin-width="0" data-origin-height="0" data-ke-mobilestyle="widthContent"|||_##]

### 컴포넌트 클래스와 템플릿의 연동

컴포넌트 클래스는 템플릿의 상태(state)를 관리한다. 데이터 바인딩(Data Binding)을 통해 템플릿에 데이터를 제공하거나 템플릿에서 발생한 이벤트를 처리한다.

[##_Image|kage@dCStIy/btqHhPDdWKp/buZfxnKTBL61NFHUi1b7Zk/img.png|alignCenter|data-origin-width="0" data-origin-height="0" data-ke-mobilestyle="widthContent"|||_##]

1.  **#inputYourName**는 템플릿 참조 변수(template reference variable)로 템플릿 내의 DOM요소에 대한 참조로서 템플릿 내에서 변수처럼 사용한다. 여기서 inputYourName.value는 input(#inputYourName)의 value를 취득하여 버튼의 클릭 이벤트 핸들러인 setName의 인자로 전달
2.  클릭 이벤트가 발생하면 컴포넌트 클래스에 정의된 setName를 호출한다. 이때 인자로 전달된 input의 value값이 컴포넌트 클래스의 name 프로퍼티에 저장된다. button 엘리먼트의 (click)은 이벤트 바인딩(event binding이라 하며 click 이벤트 발생 시 지정한 함수(핸들러 함수)를 호출한다.
3.  컴포넌트 클래스의 name 프로퍼티에 저장된 값(input 요소의 value)은 템플릿 문법인 인터플레이션( {{ name }} )에 의해 h2 요소에 삽입된다.

### 컴포넌트의 호출

루트 컴포넌트(EX> appComponent)의 경우 루트 모듈이 부트스트랩하기 때문에 애플리케이션이 실행되면 루트 컴포넌트의 뷰가 브라우저에 표시된다. 하지만**루트 컴포넌트가 아닌 컴포넌트는 다른 텀포넌트의 호출에 의해 브라우저에 랜더링 된다.**(즉 루트 컴포넌트가 아니라면 호출없이 브라우저에 랜더링 될 수 없다는 이야기)

컴포넌트를 호출하는 방법은 호출하고자 하는 컴포넌트의 selector(@Component 데코데이터에 메타데이터로 지정한)를 html엘리먼트의 형태로 컴포넌트의 템플릿에 포함하는 것으로 가능하다. 이때 호출 된 컴포넌트는 호출한 컴포넌트의 자식 컴포넌트가 된다. 컴포넌트의 부모, 자식 관계를 데이터와 이벤트가 왕래하는 정보 흐름의 통로가 되어 이를 통해 상태 공유가 이루어지기 때문에 Angular 애플리케이션에서 중요한 의미를 갖는다.

### 모듈에 컴포넌트 등록

hello 컴포넌트를 모듈(EX> app.module.ts)에 등록하는 것이 컴포넌트 사용의 마지막 단계로**모듈은 관련된 Angular 구성요소를 하나로 묶어 애플리케이션을 구성하는 하나의 단위를 만드는 역활을 한다.**  
(단 이때 angular cli의 명령어를 통해 컴포넌트를 추가했다면 자동으로 모듈에 등록된다.)

declarations 프로퍼티에는 모듈에 소속될 구성요소(컴포넌트, 디렉티브, 파이프)의 리스트를 지정한다. 그 외 @NgModule 데코레이터의 인자로 사용되는 메타데이터 객체의 중요 프로퍼티는 아래와 같다.

-   providers  
    주입 가능한 객체(injectable object), 즉 서비스의 리스트를 선언한다. 루트 모듈에 선언된 서비스는 애플리케이션 전역에서 사용할 수 있다.
    
-   declarations  
    뷰 클래스(컴포넌트, 디렉티브, 파이프)의 리스트를 선언한다.
    
-   imports  
    의존 관계에 있는 Angular 라이브러리 모듈로 기능 모듈(Feature Module)이라 불리는 하위 모듈, 라우팅 모듈, 서드 파티 모듈을 선언 한다.
    
-   bootstrap  
    애플리케이션의 진입점인 루트 컴포넌트를 선언한다.
    

## 템플릿과 템플릿 문법

### 템플릿이란?

템플릿은 HTML과 Angular 고유의 템플릿 문법으로 UI의 최소단위인 컴포넌트의 뷰를 정의하는 데 동적으로 변하는 데이터는 컴포넌트 클래스(Component Class)가 관리하며 템플릿 문법의 데이터 바인딩에 의해 정적(static) HTML에 포함된다.

[##_Image|kage@Pn3IC/btqHjWhO0HK/MIDV0xFLJscSAHhkYB5d4k/img.png|alignCenter|data-origin-width="0" data-origin-height="0" data-ke-mobilestyle="widthContent"|||_##]

[##_Image|kage@bgXSNt/btqHng09KtD/hBGZAe5XffM8z6ObKnykgk/img.png|alignCenter|data-origin-width="0" data-origin-height="0" data-ke-mobilestyle="widthContent"|||_##]

템플릿은 Angular에만 존재하는 개념은 아니며 브라우저의 요청에 동적으로 대응하여야 하는 웹 애플리케이션의 경우 서버 측에서 템플릿을 사용하는 경우가 많다.

### 템플릿 문법

템플릿 문법은 템플릿을 작성하기 위한 Angular 고유의 확장 표기법으로 템플릿과 컴포넌트 클래스 간 데이터 공유를 위한 데이터 바인딩과 동적으로 DOM구조, 스타일등을 변경할 수 있는 빌트인 디렉티브 등을 지원한다.  
(정적인 뷰는 HTML만으로 정의할 수 있지만 컴포넌트와 연계하여 동적으로 변화하는 뷰를 정의하려면 템플릿 문법이 필요하다)

Angular에서 제공하는 템플릿 문법은 아래와 같다

-   데이터 바인딩
    
    -   인터폴레이션(interpolation)
        
    -   프로퍼티 바인딩(property binding)
        
    -   어트리뷰트 바인딩(attribute binding)
        
    -   클래스 바인딩(class binding)
        
    -   스타일 바인딩(style binding)
        
    -   이벤트 바인딩(event binding)
        
    -   양방향 데이터 바인딩(two-way binding)
        
-   빌트인 디렉티브(built-in directive)
    
    -   빌트인 어트리뷰트 디렉티브(built-in attribute directive)
        
        ngClass
        
        ngStyle
        
    -   빌트인 구조 디렉티브(built-in structual directive)
        
        ngIf
        
        ngFor
        
        ngSwitch
        
-   템플릿 참조변수(template reference variable)
    
-   템플릿 표현식 연산자(template expression operator)
    

## 데이터 바인딩

### 데이터 바인딩이란?

구조화된 웹 애플리케이션을 구축하기 위해서는 뷰와 모델의 분리가 필수인데 하지만 분리된 뷰와 모델은 유기적으로 동작해야하는 모순이 생기게 되는 데 이 모순을 데이터 바인딩이 해결해준다.

데이터 바인딩은 뷰와 모델을 하나로 연결하는 것을 의미하며 Angular에서의 데이터 바인딩은 템플릿(View)와 컴포넌트 클래스의 데이터(model)를 하나로 묶어 유기적으로 동작하게 하는 것을 말하며 데이터 바인딩을 사용하는 것은 템플릿의 정적 HTML과 컴포넌트의 동적 데이터를 하나로 묶어 브라우저에 표시할 완성된 뷰를 만들기 위함이다.

Angular는 DOM에 직접 접근하지 않고 템플릿과 컴포넌트 클래스의 상호 관계를 선언하는 방식([선언형 프로그래밍](https://ko.wikipedia.org/wiki/%EC%84%A0%EC%96%B8%ED%98%95_%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D))으로 뷰와 모델의 관계를 관리하는 데 이 때 사용되는 것이 데이터 바인딩이며 이를 통해 템플릿과 컴포넌트 클래스는 연결된다. 이러한 데이터 바인딩은 템플릿 문법으로 기술되며 이렇게 기술된 템플릿은 JIT또는 AOT 컴파일러에 의해 브라우저가 이해할 수 있는 자바스크립트도 컴파일 된다.

위 예제의 경우 템플릿에서 직접 컴포넌트 클래스의 프로퍼티를 참조하기 때문에 DOM에 접근하고 조작하는 코드($(‘div’)라던지 document.getElementById와 같은)를 작성할 필요가 없다.  
그러므로 DOM의 구조를 파악하고 있을 필요도 템플릿(DOM)의 구조가 변경되어도 컴포넌트 클래스를 변경할 필요가 없다.

이렇게 Angular의 데이터 바인딩은 뷰와 모델의 관계를 기존의 웹 애플리케이션의 방식보다 느슨하게 결합하므로 뷰와 모델을 보다 깔끔하게 분리할 수 있으며 코드도 더 간결하게 개발할 수 있다.

Angular는 단방향, 양방향 데이터 바인딩을 지원하여 기존의 웹 프로그래밍에서 사용하는 DOM조작 방식보다 간편하게 데이터를 가져와서 뷰에 표현할 수 있다.

데이터 바인딩데이터의 흐름문법

<table style="border-collapse: collapse; width: 100%;" border="1"><tbody><tr><td>인터폴레이션</td><td>컴포넌트 클래스 -&gt; 템플릿</td><td>{{ expression }}</td></tr><tr><td>프로퍼티 바인딩</td><td>컴포넌트 클래스 -&gt; 템플릿</td><td>[property]=”expression”</td></tr><tr><td>어트리뷰트 바인딩</td><td>컴포넌트 클래스 -&gt; 템플릿</td><td>[attr.attribute-name]=”expression”</td></tr><tr><td>클래스 바인딩</td><td>컴포넌트 클래스 -&gt; 템플릿</td><td>[class.class-name]=”expression”</td></tr><tr><td>스타일 바인딩</td><td>컴포넌트 클래스 -&gt; 템플릿</td><td>[style.style-name]=”expression”</td></tr><tr><td>이벤트 바인딩</td><td>컴포넌트 클래스 &lt;- 템플릿</td><td>(event)=”statement”</td></tr><tr><td>양방향 데이터 바인딩</td><td>컴포넌트 클래스 &lt;-&gt; 템플릿</td><td>[(ngModel)]=”property”</td></tr></tbody></table>

### 인터폴레이션(interpolation)

표현식을 두 개의 중괄호로 열고닫은 형식으로 표현하는 템플릿 문법으로 단방향 데이터 바인딩에 사용하며 표현식의 평과 결과(expression)를 문자열로 반환하여 템플릿에 바인딩한다.

컴포넌트 클래스의 프로퍼티가 문자열이 아닌 경우 문자열로 변환되며 존재하지 않는 프로퍼티에 접근하는 경우(gender) 에러 발생 없이 아무 것도 출력하지 않는다

### 프로퍼티 바인딩

프로퍼티 바인딩은 표현식의 평가 결과를 HTML요소의 DOM 프로퍼티에 바인딩한다.

인터폴레이션({{ expression }})은 순수한 문자열을 반환하기 때문에 HTML 콘텐츠, 어트리뷰트의 값 등 템플릿의 어디에서나 사용할 수 있다.

Angular는 뷰를 랜더링하기 이전에 인터폴레이션을 프로퍼티 바인딩으로 변환하는 과정을 거친다 사실 인터폴레이션은 프로퍼티 바인딩의 문법적 설탕이다.

프로퍼티 바인딩에는 객체를 포함한 모든 값을 사용할 수 있는 데 이는 DOM 노드 객체의 프로퍼티에는 객체를 포함한 모든 값을 할당할 수 있기 때문이다. 이 특성을 이용하여 부모 컴포넌트에서 자식 컴포넌트로 값을 전달하는 경우 프로퍼티 바인딩을 사용한다.

### 어트리뷰트 바인딩

어트리뷰트 바인딩은 표현식의 평가 결과를 HTML 어트리뷰트에 바인딩한다.

프로퍼티와 어트리뷰트는 모두 속성으로 번역되어 같은 것으로 오해할 수 있으나 이들은 서로 다른 것으로 어트리뷰트는 HTML문서에 존재하는 것으로 어트리뷰트의 값은 변하지 않지만 프로퍼티는 DOM 노드 객체에 있는 것으로 동적으로 변한다.

### 클래스 바인딩

클래스 바인딩은 HTML요소의 class 어트리뷰트에 클래스 추가 또는 삭제할 수 있으며 상황에 따라 다항, 단항 두가지 방식으로 사용할 수 있다.

단항 클래스 바인딩

단항 클래스 바인딩은 좌변에는 ‘class’ 뒤에는 html 요소에 반영할 class 어트리뷰트 명을 지정하고 우변에는 참이나 거짓으로 평가될 수 있는 표현식을 바인딩 한다.

표현식이 참인 경우 지정한 class 어트리뷰트 명이 추가되고 그렇지 않은 경우 삭제되는 데 기존에 다른 class가 존재하는 경우에는 존재하는 class에 영향 없이 추가, 삭제되며 추가하려는 class가 이미 존재하는 경우라면 표현식에 따라 표기되거나 삭제 된다.

다항 클래스 바인딩

다항 클래스 바인딩은 좌변에는 “class”를 지정하고 우변에는 HTML 요소에 반영할 클래스 이름을 리스트로 바인딩한다. (이때 리스트의 구분은 공백)

단항 클래스 바인딩과의 가장 큰 차이는 기존에 선언되어 있는 class명을 대체한다는 것이다.

**클래스 바인딩은 주로 하나의 클래스를 조건에 의해 추가, 삭제하는 용도로 사용되며 여러 개의 클래스를 지정할때도 사용할 수 있으나 ngClass 디렉티브를 사용하면 좀 더 세밀하게 제어할 수 있다.**

### 스타일 바인딩

스타일 바인딩은 HTML요소의 style 어트리뷰트에 스타일을 바인딩 한다.

만약 지정하는 스타일 값에 단위가 필요하다면 아래와 같이 사용할 수 있다.

주의할 것은 style 어트리뷰트에 의해 이미 스타일이 지정되어 있을 때 중복되지 않은 스타일은 추가되고 중복된 스타일은 대체된다. 즉 스타일 바인딩은 기존의 style 어트리뷰트보다 우선한다.

스타일 프로퍼티의 이름(border-radius 등)은 케밥 표기법(kebab-case) 또는 카멜 표기법(camelCase)를 사용한다.

또한 아래와 같이 삼항연산자를 응용하여 조건에 따라 다른 스타일을 지정할 수도 있다.

**스타일 바인딩은 주로 하나의 인라인 스타일을 조건에 의해 추가하는 용도로 사용되며 여러개의 인라인 스타일을 추가해야 하는 경우 ngStyle 디렉티브를 사용한다.**

### 이벤트 바인딩

이벤트 바인딩(event binding)은 뷰의 상태 변화(체크박스 체크, input에 텍스트 입력, 버튼 클릭 등)에 의해 이벤트가 발생하면 이벤트 핸들러를 호출하는 것을 말한다.  
앞서 살펴본 데이터 바인딩은 모두 컴포넌트 클래스 -> 템플릿의 형태로 데이터가 이동하였지만 이벤트 바인딩은 템플릿 -> 컴포넌트 클래스로 데이터가 이동한다.

### 양방향 데이터 바인딩

양반향 데이터 바인딩(Two-way Data Binding)은 뷰와 컴포넌트 클래스의 상태 변화를 상호 반영하는 것을 말한다.

ngModel 디렉티브를 이벤트 바인딩 ‘()’ 과 프로퍼티 바인딩 ‘\[\]’ 형식으로 기술한 후 우변에는 뷰와 컴포넌트 클래스가 공유할 프로퍼티를 기술한다.  
ngModel 디렉티브를 사용하기 위해서는 FormsModule을 모듈(EX> app.module.ts)에 등록하여야 한다.

컴포넌트 클래스의 name 프로퍼티는 템플릿의 input 요소와 양방향바인딩 되어 있다. 즉 input 요소의 value 프로퍼티나 컴포넌트 클래스의 name 프로퍼티가 변화하면 양쪽 모두 동일한 값으로 변화한다.

사실 angular는 양방향 데이터 바인딩을 지원하지 않는다. 양방향 바인딩의 문법인 ‘\[()\]’ 에서 추측할 수 있듯 이벤트 바인딩과 프로퍼티 바인딩의 축약 표현(shorthand syntax)으로 실제 동작은 이벤트 바인딩과 프로퍼티 바인딩의 조합으로 이루어진다. 이벤트, 프로퍼티 바인딩을 통해 위의 예제와 동일하게 동작하도록 작성할 수 있다.

즉 ngModel은 이벤트 바인딩과 프로퍼티 바인딩으로 구현되는 양방향 바인딩을 간편하게 작성할 수 있도록 돕는 디렉티브로서 사용자 입력에 관련한 DOM요소(form 컨트롤 요소)에서만 사용할 수 있다.

## 빌트인 디렉티브

### 빌트인 디렉티브란?

디렉티브(Directive, 지시자)는 “DOM의 모든 것(모양이나 동작)을 관리하기 위한 지시(명령)으로 HTML요소 또는 어트리뷰트의 형태로 사용하거나 디렉티브가 사용된 요소에게 무언가를 하라는 지시를 전달한다.

**디렉티브는 애플리케이션 전역에서 사용할 수 있는 공통 관심사를 컼포넌트에서 분리하여 구현한 것으로 컴포넌트의 복잡도를 낮추고 가독성을 향상시킨다**(컴포넌트도 뷰를 생성하ㅗ 이벤트를 처리하는 등의 DOM을 관리하기 때문에 큰 의미에서 디렉티브로 볼 수 있다.)

-   컴포넌트 디렉티브(Component Directive)
    
    컴포넌트의 템플릿을 표시하기 위한 디렉티브이다. @Component 데코레이터의 메타데이터 객체 selector 프로퍼티에 임의의 디렉티브 이름을 정의한다.
    
-   어트리뷰트 디렉티브(Attribute Directive)  
    HTML요소의 어트리뷰트와 같이 사용하여 호스트 요소의 모양이나 동작을 제어한다. ngClass, ngStyle과 같은 빌트인 어트리뷰트 디렉티브가 있다.
-   구조 디렉티브 (Structural Directive)  
    DOM요소의 반복 생성(ngFor), 조건에 의한 추가 또는 제거(ngIf, ngSwitch)를 통해 DOM 레이아웃을 변경한다.

### 빌트인 어트리뷰트 디렉티브

#### ngClass

여러 개의 CSS 클래스를 추가, 제거하는 디렉티브  
(단 한 개의 클래스를 추가, 제거할때는 클래스 바인딩( \[class\] )을 사용하는 것이 좋다.)

클래스 바인딩( \[class\] )의 경우 기존의 class 어트리뷰트를 삭제하는 것과 달리 ngClass 디렉티브는 기존 class 어트리뷰트를 병합하여 작성한다.

#### ngStyle

여러 개의 인라인 스타일을 추가, 제거한다.  
(한 개의 인라인 스타일을 추가, 제거할때는 스타일 바인딩 ( \[style\] )을 사용하는 것이 좋다)

ngStyle 디렉티브에 바인딩된 객체는 CSS 프로퍼티를 프로퍼티 이름으로, CSS프로퍼티의 값을 프로퍼티 값으로 갖는다. 이때 값에 단위가 필요한 경우 CSS 프로퍼티에 단위를 추가한다.  
ngClass 디렉티브와 마찬가지로 기존에 style어트리뷰트에 의해 이미 지정되어 있는 값이 있는 경우 병합된다.

### 빌트인 구조 디렉티브

Angular가 제공하는 구조 디렉티브로 DOM 요소의 반복 생성(ngFor)과 조건에 의한 추가 또는 제거를 수행(ngIf)하여 뷰의 구조를 변경한다.

-   구조 디렉티브에는 ‘\[\]’가 아닌 접두사 \*(asterisk) 추가하여 사용한다.
    
-   하나의 호스트 요소(디렉티브가 선언된 요소)에는 하나의 구조 디렉티브만을 사용할 수 있다.
    

#### ngIf

우변의 표현식의 연산에 따라 DOM을 추가, 제거한다. 이때 우변의 표현식의 결과는 반드시 true, false(Boolean)로 평가될 수 있어야 한다.  
(DOM을 숨기는 것이 아닌 추가, 제거이며 제거된 요소는 DOM에 남아있지 않고 완전히 제거되어 불필요한 자원의 낭비를 방지한다.)

Angular4부터 ngIf else가 추가되었다. 우변의 표현식이 참이면 호스트 요소를 DOM에 추가하고 거짓이면 else 이후에 기술한 ng-template 디렉티브의 자식을 DOM에 추가한다  
이때 ng-template 디렉티브에는 else 또는 then 이후에 지정한 템플릿 참조변수를 지정한다.

#### ngFor

ngFor 디렉티브는 컴포넌트 클래스의 컬렉션(배열과 같은 이터러블 객체)을 반복하여 ngFor 디렉티브가 선언된 요소(호스트 요소) 및 하위 요소를 DOM에 추가한다. ngFor 디렉티브에 바인딩된 ES6의[for…of](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Statements/for...of)와 유사하게 동작한다.

컴포넌트 클래스의 프로퍼티 items를 바인딩한 후 items의 요소 개수만큼 순회하며 개별 요소를 item에 할당한다. item(템플릿 입력변수)은 호스트 요소 및 하위 요소에서만 유효한 로컬 변수로 items에 해당하는 바인딩 객체는 일반적으로 배열을 사용하지만 반드시 배열만 사용할 수 있는 것은 아니다. (ES6의 for…of에서 사용할 수 있는 이터러블(iterable)이라면 사용이 가능하다)

ngFor 디렉티브는 컬렉션 데이터(users 배열)가 변경되면 컬렉션과 연결된 모든 DOM요소를 제거하고 다시 생성한다. 이는 컬렉션의 변경사항을 추적(tracking)할 수 없기 때문으로 크기가 매우 큰 컬렉션을 다루는 경우을 다루는 경우 퍼포먼스 상의 문제를 발생시킬 수 있다.

  
이러한 이유로 ngFor디렉티브에서는 퍼포먼스를 향상시키기 위한 기능으로 trackBy를 제공한다.  
(일반적인 경우 ngFor는 충분히 빠르기 때문에 trackBy에 의한 퍼포먼스 최적화는 기본적으로 필요 없기때문에 퍼포먼스 문제가 발생하는 경우에만 사용하면 된다.)

#### ngSwitch

switch 조건에 따라 여러 요소 중에 하나의 요소를 선택하여 DOM에 추가하는 디렉티브로 자바스크립트의 switch문과 유사하게 동작한다.

##참고

https://poiemaweb.com/ -> Angular 부분
Angular Essentials-이웅모/루비페이퍼
